gsap.registerPlugin(ScrollTrigger) //Gsap scroll trigger plugin

document.addEventListener("DOMContentLoaded", () => { // Ensure DOM is loaded before running animations
  const tl = gsap.timeline(); // Create a timeline for landing page animations

  // Robot head enters from right
  tl.to(".robot-head", { // Target robot head element
    x: 0, // Move to original position
    opacity: 1, // opacity 0 was originally done in css to make it visually more smooth
    duration: 1.5, // Animation duration
    ease: "power3.out" // Easing function for smooth effect
  });

  // Heading slides from left right after the robot head
  tl.to(".heading", { // Target heading element
    x: 0, // Move to original position
    opacity: 1, // opacity 0 was originally done in css to make it visually more smooth
    duration: 1.2, // Animation duration
    ease: "power3.out" // Easing function for smooth effect
  }, "<0.3"); // "<0.3" so that it starts 0.3s after robot head starts

  tl.to(".purpose", { // Target purpose element
    y:0, // Move to original position
    opacity: 1, // opacity 0 was originally done in css to make it visually more smooth
    duration: 1, // Animation duration
    ease: "power3.out" // Easing function for smooth effect
  }, "<0.3"); // "<0.3" so that it starts 0.3s after heading starts
});

let tl = gsap.timeline({ 
  scrollTrigger: { // ScrollTrigger
    trigger: "body", // what element triggers the animation, body is perfect here because it covers the whole page
    start: "top top", // animation starts from the top of the page by top of the element
    end: "+=1600", // user scrolls more than or equal to 1600px to finish animation 
    scrub: 2, // animation follows scroll movement. scrub ensures complete control of animation with scrolling and 2 makes delay for smoothness
    pin: ".robot-head", // pin the robot head container so the animation is fixed on the main subject (which is robot head)
  }
});

// Robot and text animations
tl.to(".robot-front", { x: -1360, y:45, duration: 2 }); // Move robot front left and slightly down
tl.to(".robot-back", { x: 780, y:-180, duration: 2 }, "<"); //this < makes it start at the same time as previous animation with no time delay
tl.to(".robot-head", { x: -400, duration: 1 }, "<"); // Robot head moves down at the same time
tl.to(".text-ai", {x: -1360, y:145, duration: 1}, "<"); // AI symbol goes away with the robot-front
tl.to(".text-ml", { opacity:1, duration: 1.2}, "<") // ML text appears on the robot brain smoothly

// Brain flicker animations
tl.to(".robot-brain-f", { opacity: 1, duration: 0.1 }, "<0.2"); // Flicker effect for brain front
tl.to(".robot-brain-m", { opacity: 1, duration: 0.1 }, "<0.1"); // Flicker effect for brain middle but with slight delay
tl.to(".robot-brain-b", { opacity: 1, duration: 0.1 }, "<0.1"); // Flicker effect for brain back but with slight delay
tl.to(".text-ml", { opacity: 1, duration: 0.3 }, "<"); // ML text on the brain doesn't flicker and maintains its opacity

tl.to(".robot-brain-f", { x:-50, y: 20, duration: 1 }); // Move brain front a little ahead
tl.to(".robot-brain-m", { y: -20, duration: 1 }, "<"); // Move brain middle a little up at the same time
tl.to(".robot-brain-b", { x: 80, y: -30, duration: 1 }, "<"); // Move brain back a little right and up at the same time
tl.to(".text-ml", { opacity:1, duration:1}, "<"); // Keep ML text visible
tl.to(".text-ml", { opacity:0, duration:1}, "<"); // ML text fades out only now, it was important to keep the opacity 1 during brain movement because otherwise there was some weird opacity drop was persistent in the previous time when brain was just exposed. I think people who've used After Effects would know this 
tl.to(".super", { opacity:1, duration:1}, "<"); // Supervised text appears the moment brain front reaches its position however the opacity 1 ensures smoothness 
tl.to(".unsuper", { opacity:1, duration:1}, "<"); // Unsupervised text appears the moment brain middle reaches its position however the opacity 1 ensures smoothness
tl.to(".reinforce", { opacity:1, duration:1}, "<"); // Reinforcement text appears the moment brain back reaches its position however the opacity 1 ensures smoothness

// Glow rays animation
tl.to(".glow-ray-f",{height: 390, duration:0.8}); // Glow ray front expands
tl.to(".glow-ray-m",{height: 1000, duration:0.8}, "<"); // Glow ray middle expands at the same time
tl.to(".glow-ray-b",{height: 390, duration:0.8} , "<"); // Glow ray back expands at the same time

const musicSwitch = document.querySelector('.switch'); // Music toggle switch
const bgMusic = document.querySelector('.bgMusic'); // Background music audio element to trigger the audio

// The below code is generated by claude AI:-

// Note: Most browsers block autoplay until user interact so I had to make the default switch as OFF rather than ON

// Listen for switch changes
musicSwitch.addEventListener('sl-change', (e) => { // This is saying to JS that when an event happens on sl-switch (sl-change) then only run this code. e is an event object that represents what happened 
    if (e.target.checked) { // if-else function where if the the e(event object) is checked then 
        bgMusic.play(); // play the bgMusic 
    } else { // if unchecked
        bgMusic.pause(); // pause immediately
    }
});

{
    const carousel = document.querySelector('.carousel-thumbnails'); // setting carousel as constant 
    const scroller = document.querySelector('.thumbnails__scroller'); // setting scroller as constant
    const thumbnails = document.querySelectorAll('.thumbnails__image'); // setting thumbnails as constant
    // I'm setting these to constants and not variables is because we're not gonna be needing to change them later at all

    scroller.addEventListener('click', e => { // Adding event listener to click. scroller is an element that holds thumbnail images
      const target = e.target; // this is to set a target of 'click' about where it must happen to trigger the following function

      if (target.matches('.thumbnails__image')) { // Its an if function. It checks whether the click is on .thumbnail-images element in css or not. If yes then run the code
        const index = [...thumbnails].indexOf(target); // The thumbnails are set as arrays, index of (target) gives a numerical value to the target slide
        carousel.goToSlide(index); // goToSlide tells to jump on the next image as per the index
      }
    });

    carousel.addEventListener('sl-slide-change', e => { // the e here happens when the slide is changed
      const slideIndex = e.detail.index; // gives the number (index) of the current active slide

      [...thumbnails].forEach((thumb, i) => { // [...thumbnails] converts thumbnails into loops so we can swipe around easily
        thumb.classList.toggle('active', i === slideIndex); // adds or removes a CSS class. active addes class only to the active slide this is to highlight the current image
        if (i === slideIndex) { // This checks whether this is the thumbnail that matches the active slide or not. === checks value and type both to be 100% sure
          thumb.scrollIntoView({ // If yes, this scrolls the thumbnail container
            block: 'nearest' // This makes sures to scroll only the amount that is needed to show it
          });
        }
      });
    });
  }

// Below code is mine:-

let shoeButton = document.querySelector('.shoe-button'); //setting as variables, could have set as constant as well but never mind
let blackBelow = document.querySelector('.black-below'); //setting as variables, could have set as constant as well but never mind
let carouselContainer = document.querySelector('.carousel-container'); //setting as variables, could have set as constant as well but never mind

shoeButton.addEventListener('click', () => { // Once the click event happens on the shoeButton
  blackBelow.style.display = 'flex'; // the black below screen becomes visible by display flex
  carouselContainer.style.display = 'block'; // the image carousel comes alive as display block
});

blackBelow.addEventListener('click', () => { // Once the user clicks on the blackBellow
  blackBelow.style.display = 'none'; // The black below disappears
  carouselContainer.style.display = 'none'; // Image carousel disappears
})

// Array for each page
const pages = [
  document.querySelector('.Intro-content'),
  document.querySelector('.page-two'),
  document.querySelector('#page-three'),
  document.querySelector('#page-four'),
  document.querySelector('#page-five')
]; // this sets all the content pages into arrays which we can easily loop around

// A variable to store the current array index
let currentIndex = 0; //sets the 1st page index value as 0

// Function to scroll smoothly to a page and update the index
/* I took help of AI to write this step*/
function scrollToPage(index) { // Sets a condition for function for scrolltopage
  if (index >= 0 && index < pages.length) { // If function. this basically sets some conditions before any action begins. index >=0 means to sure the number isn’t negative. index < pages.length ensures it is less than the total number of pages
    pages[index].scrollIntoView({ behavior: 'smooth' }); // If the above conditions are met, only then run this code. scrollIntoView brings scroll element into view. behaviour-smooth ensures realistic scroll behaviour
    currentIndex = index; // Updates index with new page
    updateButtonState(); // changes the behaviour of back and next button
  }
}

// For disabling buttons on first/last page
function updateButtonState() { // Making backward forward buttons functionable
  const backButton = document.querySelector('.backward-button'); // Setting it as const
  const forwardButton = document.querySelector('.forward-button'); // Setting it as const

  backButton.disabled = currentIndex === 0; // When the current index is 0 (meaning we are at the landing page), the backward button is disabled
  forwardButton.disabled = currentIndex === pages.length - 1; //Same here
}

//Event listeners for navigation buttons
document.querySelector('.forward-button').addEventListener('click', () => { // Adding events to navigation button forward
  if (currentIndex < pages.length - 1) { // If function here. it says that run the code only when this condition is met- Check if you’re not on the last page yet.
    scrollToPage(currentIndex + 1); // Moves to the next page smoothly.
  }
});

document.querySelector('.backward-button').addEventListener('click', () => { // Adding for navigation button backward
  if (currentIndex > 0) { // If current index is not 0. Means it only works if you're not on first page
    scrollToPage(currentIndex - 1); // Scroll one page back (-1) when clicked
  }
});

// 6. Detect which page is in view and update index
window.addEventListener('scroll', () => { // An event listener for scroll
  pages.forEach((page, index) => { // goes through each page in pages array
    const rect = page.getBoundingClientRect(); // Realise the page’s position on the screen
    if (rect.top >= 0 && rect.top < window.innerHeight / 2) { // If the top of that page is somewhere in the top half of the screen, that means this is the page currently being viewed.
      currentIndex = index; 
      updateButtonState(); // Updates the current page number
    }
  });
});

// 7. Run the functions initially
updateButtonState(); // Runs once at the start to make sure the buttons are correctly set when the page first loads.